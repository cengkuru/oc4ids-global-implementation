{"ast":null,"code":"/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { secretToken } from '../../internals/secrets.js';\nimport { HtmlSanitizerImpl } from './html_sanitizer.js';\nimport { DEFAULT_SANITIZER_TABLE } from './sanitizer_table/default_sanitizer_table.js';\nimport { AttributePolicyAction, SanitizerTable, isCustomElement } from './sanitizer_table/sanitizer_table.js';\n/** This class allows modifications to the default sanitizer configuration. */\nexport class HtmlSanitizerBuilder {\n  constructor() {\n    // To denote if the builder has called build() and therefore should make no\n    // further changes to the sanitizer table.\n    this.calledBuild = false;\n    this.sanitizerTable = DEFAULT_SANITIZER_TABLE;\n  }\n  /** Builder option to restrict allowed elements to a smaller subset. */\n  onlyAllowElements(elementSet) {\n    const allowedElements = new Set();\n    const allowedElementPolicies = new Map();\n    for (let element of elementSet) {\n      element = element.toUpperCase();\n      if (!this.sanitizerTable.isAllowedElement(element)) {\n        throw new Error(`Element: ${element}, is not allowed by html5_contract.textpb`);\n      }\n      const elementPolicy = this.sanitizerTable.elementPolicies.get(element);\n      if (elementPolicy !== undefined) {\n        allowedElementPolicies.set(element, elementPolicy);\n      } else {\n        allowedElements.add(element);\n      }\n    }\n    this.sanitizerTable = new SanitizerTable(allowedElements, allowedElementPolicies, this.sanitizerTable.allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies);\n    return this;\n  }\n  /**\n   * Builder option to allow a set of custom elements. Must be called either\n   * without or after `onlyAllowElements` - will be overwritten otherwise.\n   * Custom elements must contain a dash.\n   */\n  allowCustomElement(element, allowedAttributes) {\n    const allowedElements = new Set(this.sanitizerTable.allowedElements);\n    const allowedElementPolicies = new Map(this.sanitizerTable.elementPolicies);\n    element = element.toUpperCase();\n    if (!isCustomElement(element)) {\n      throw new Error(`Element: ${element} is not a custom element`);\n    }\n    if (allowedAttributes) {\n      const elementPolicy = new Map();\n      for (const attribute of allowedAttributes) {\n        elementPolicy.set(attribute, {\n          policyAction: AttributePolicyAction.KEEP\n        });\n      }\n      allowedElementPolicies.set(element, elementPolicy);\n    } else {\n      allowedElements.add(element);\n    }\n    this.sanitizerTable = new SanitizerTable(allowedElements, allowedElementPolicies, this.sanitizerTable.allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies);\n    return this;\n  }\n  /**\n   * Builder option to restrict allowed attributes to a smaller subset.\n   *\n   * If the attribute isn't currently allowed then it won't be added.\n   */\n  onlyAllowAttributes(attributeSet) {\n    const allowedGlobalAttributes = new Set();\n    const globalAttributePolicies = new Map();\n    const elementPolicies = new Map();\n    for (const attribute of attributeSet) {\n      if (this.sanitizerTable.allowedGlobalAttributes.has(attribute)) {\n        allowedGlobalAttributes.add(attribute);\n      }\n      if (this.sanitizerTable.globalAttributePolicies.has(attribute)) {\n        globalAttributePolicies.set(attribute, this.sanitizerTable.globalAttributePolicies.get(attribute));\n      }\n    }\n    for (const [elementName, originalElementPolicy] of this.sanitizerTable.elementPolicies.entries()) {\n      const newElementPolicy = new Map();\n      for (const [attribute, attributePolicy] of originalElementPolicy.entries()) {\n        if (attributeSet.has(attribute)) {\n          newElementPolicy.set(attribute, attributePolicy);\n        }\n      }\n      elementPolicies.set(elementName, newElementPolicy);\n    }\n    this.sanitizerTable = new SanitizerTable(this.sanitizerTable.allowedElements, elementPolicies, allowedGlobalAttributes, globalAttributePolicies);\n    return this;\n  }\n  /**\n   * Allows the set of data attributes passed.\n   *\n   * These values must be prefixed with \"data-\"\n   *\n   * If called with onlyAllowElements or onlyAllowAttributes, those methods must\n   * be called first.\n   */\n  allowDataAttributes(attributes) {\n    const allowedGlobalAttributes = new Set(this.sanitizerTable.allowedGlobalAttributes);\n    for (const attribute of attributes) {\n      if (attribute.indexOf('data-') !== 0) {\n        throw new Error(`data attribute: ${attribute} does not begin with the prefix \"data-\"`);\n      }\n      allowedGlobalAttributes.add(attribute);\n    }\n    this.sanitizerTable = new SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies);\n    return this;\n  }\n  /**\n   * Preserves style attributes. Note that the sanitizer won't parse and\n   * sanitize the values but keep them as they are. In particular this means\n   * that the code will be able to call functions that could do undesirable\n   * things (e.g. `url` to trigger a network request), as well as any custom\n   * properties or functions defined by the application.\n   */\n  allowStyleAttributes() {\n    const globalAttributePolicies = new Map(this.sanitizerTable.globalAttributePolicies);\n    globalAttributePolicies.set('style', {\n      policyAction: AttributePolicyAction.KEEP_AND_SANITIZE_STYLE\n    });\n    this.sanitizerTable = new SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, this.sanitizerTable.allowedGlobalAttributes, globalAttributePolicies);\n    return this;\n  }\n  /**\n   * Preserves the class attribute on all elements. This means contents can\n   * adopt CSS styles from other page elements and possibly mask themselves as\n   * legitimate UI elements, which can lead to phishing.\n   */\n  allowClassAttributes() {\n    const allowedGlobalAttributes = new Set(this.sanitizerTable.allowedGlobalAttributes);\n    allowedGlobalAttributes.add('class');\n    this.sanitizerTable = new SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies);\n    return this;\n  }\n  /**\n   * Preserves id attributes. This carries moderate risk as it allows an\n   * element to override other elements with the same ID.\n   */\n  allowIdAttributes() {\n    const allowedGlobalAttributes = new Set(this.sanitizerTable.allowedGlobalAttributes);\n    allowedGlobalAttributes.add('id');\n    this.sanitizerTable = new SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies);\n    return this;\n  }\n  /**\n   * Preserves (some) attributes that reference existing ids. This carries a\n   * moderate security risk, because sanitized content can create semantic\n   * associations with existing elements in the page, regardless of the layout.\n   * This could be used to override the label associated with a form input by a\n   * screen reader, and facilitate phishing.\n   */\n  allowIdReferenceAttributes() {\n    const allowedGlobalAttributes = new Set(this.sanitizerTable.allowedGlobalAttributes);\n    // TODO(b/190693339): Generate this subtable from the contract.\n    allowedGlobalAttributes.add('aria-activedescendant').add('aria-controls').add('aria-labelledby').add('aria-owns').add('for').add('list');\n    this.sanitizerTable = new SanitizerTable(this.sanitizerTable.allowedElements, this.sanitizerTable.elementPolicies, allowedGlobalAttributes, this.sanitizerTable.globalAttributePolicies);\n    return this;\n  }\n  /**\n   * Sets the ResourceUrlPolicy to be used by the sanitizer.\n   *\n   * The ResourceUrlPolicy can be used to decide whether a given URL is allowed\n   * to be loaded as an external resource. It is a function that an instance\n   * of `URL` and a set of hints giving a context on why an image was loaded.\n   *\n   * The policy can return `null` to indicate that the resource should be\n   * dropped, otherwise it should return a valid `URL` that will be used to\n   * replace the original URL in the sanitized output.\n   *\n   * For example the following policy will allow all images loaded from\n   * `https://google.com` but will drop all images loaded from\n   * `https://forbidden.google.com`.\n   *\n   * ```typescript\n   * const resourceUrlPolicy: ResourceUrlPolicy = (url) => {\n   *   if (url.hostname === 'forbidden.google.com') {\n   *     return null;\n   *   }\n   *   return url;\n   * };\n   * ```\n   *\n   * You can also use the `ResourceUrlPolicyHints` to make the policy more\n   * informed. For example the following policy will only allow images loaded\n   * via a <img src> tag but will drop all other images.\n   *\n   * ```typescript\n   * const resourceUrlPolicy: ResourceUrlPolicy = (url, hints) => {\n   *   if (hints.type === ResourceUrlPolicyHintsType.HTML_ATTRIBUTE &&\n   *       hints.attributeName === 'src' &&\n   *       hints.tagName === 'IMG') {\n   *     return url;\n   *   }\n   *   return null;\n   * };\n   * ```\n   */\n  withResourceUrlPolicy(resourceUrlPolicy) {\n    this.resourceUrlPolicy = resourceUrlPolicy;\n    return this;\n  }\n  build() {\n    if (this.calledBuild) {\n      throw new Error('this sanitizer has already called build');\n    }\n    this.calledBuild = true;\n    return new HtmlSanitizerImpl(this.sanitizerTable, secretToken, undefined,\n    // TODO(securitymb): Add a style element sanitizer.\n    undefined,\n    // TODO(securitymb): Add a style attribute sanitizer.\n    this.resourceUrlPolicy);\n  }\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}