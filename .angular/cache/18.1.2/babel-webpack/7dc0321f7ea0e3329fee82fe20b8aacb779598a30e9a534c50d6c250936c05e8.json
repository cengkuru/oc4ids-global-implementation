{"ast":null,"code":"/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\n/**\n * @fileoverview This contains safe wrappers for properties that aren't specific\n * to one kind of HTMLElement (like innerHTML), plus other setters and functions\n * that are not tied to elements (like location.href or Worker constructor).\n */\nimport '../../environment/dev.js';\nimport { unwrapAttributePrefix } from '../../internals/attribute_impl.js';\nimport { unwrapHtml } from '../../internals/html_impl.js';\n/**\n * Safely set {@link Element.innerHTML} on a given ShadowRoot or Element which\n * may not be a `<script>` element or a `<style>` element.\n */\nexport function setInnerHtml(elOrRoot, v) {\n  if (isElement(elOrRoot)) {\n    throwIfScriptOrStyle(elOrRoot);\n  }\n  elOrRoot.innerHTML = unwrapHtml(v);\n}\n/**\n * Safely set {@link Element.outerHTML} for the given Element.\n */\nexport function setOuterHtml(e, v) {\n  const parent = e.parentElement;\n  if (parent !== null) {\n    throwIfScriptOrStyle(parent);\n  }\n  e.outerHTML = unwrapHtml(v);\n}\n/**\n * Safely call {@link Element.insertAdjacentHTML} for the given Element.\n */\nexport function insertAdjacentHtml(element, position, v) {\n  const tagContext = position === 'beforebegin' || position === 'afterend' ? element.parentElement : element;\n  if (tagContext !== null) {\n    throwIfScriptOrStyle(tagContext);\n  }\n  element.insertAdjacentHTML(position, unwrapHtml(v));\n}\n/**\n * Given a set of known-to-be-safe prefixes (e.g., \"data-\", \"aria-\", \"js\"),\n * return a setter function that allows you to set attributes on an element,\n * as long as the names of the attributes to be set has one of the prefixes.\n *\n * The returned setter ensures that setting any dangerous attribute, e.g.,\n * \"src\", \"href\" will cause an exception. This is intended to be used as the\n * safe alterantive of `Element#setAttribute`, when applications need to set\n * attributes that do not have security implications and do not have a\n * corresponding DOM property.\n */\nexport function buildPrefixedAttributeSetter(prefix, ...otherPrefixes) {\n  const prefixes = [prefix, ...otherPrefixes];\n  return (e, attr, value) => {\n    setPrefixedAttribute(prefixes, e, attr, value);\n  };\n}\n/**\n * The safe alternative to Element#setAttribute. The function takes a list of\n * `SafeAttributePrefix`, making developer intention explicit. The attribute\n * to be set must has one of the safe prefixes, otherwise the function throws\n * an Error.\n */\nexport function setPrefixedAttribute(attrPrefixes, e, attr, value) {\n  if (attrPrefixes.length === 0) {\n    let message = '';\n    if (process.env.NODE_ENV !== 'production') {\n      message = 'No prefixes are provided';\n    }\n    throw new Error(message);\n  }\n  const prefixes = attrPrefixes.map(s => unwrapAttributePrefix(s));\n  const attrLower = attr.toLowerCase();\n  if (prefixes.every(p => attrLower.indexOf(p) !== 0)) {\n    throw new Error(`Attribute \"${attr}\" does not match any of the allowed prefixes.`);\n  }\n  e.setAttribute(attr, value);\n}\nfunction throwIfScriptOrStyle(element) {\n  let message = '';\n  const tagName = element.tagName;\n  if (tagName === 'SCRIPT' || tagName === 'STYLE') {\n    if (process.env.NODE_ENV !== 'production') {\n      if (tagName === 'SCRIPT') {\n        message = 'Use safeScriptEl.setTextContent with a SafeScript.';\n      } else {\n        message = 'Use safeStyleEl.setTextContent with a SafeStyleSheet.';\n      }\n    }\n    throw new Error(message);\n  }\n}\nfunction isElement(elOrRoot) {\n  return elOrRoot.nodeType === 1; // Node.ELEMENT_NODE\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}