{"ast":null,"code":"/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport { createHtmlInternal, isHtml, unwrapHtml } from '../internals/html_impl.js';\nimport { unwrapResourceUrl } from '../internals/resource_url_impl.js';\nimport { unwrapScript } from '../internals/script_impl.js';\n/**\n * Returns HTML-escaped text as a `SafeHtml` object. No-op if value is already a\n * SafeHtml instance.\n *\n * Available options:\n * - `preserveSpaces` turns every second consecutive space character into its\n * HTML entity representation (`&#160;`).\n * - `preserveNewlines` turns newline characters into breaks (`<br>`).\n * - `preserveTabs` wraps tab characters in a span with style=white-space:pre.\n */\nexport function htmlEscape(value, options = {}) {\n  if (isHtml(value)) {\n    return value;\n  }\n  let htmlEscapedString = htmlEscapeToString(String(value));\n  if (options.preserveSpaces) {\n    // Do this first to ensure we preserve spaces after newlines and tabs.\n    htmlEscapedString = htmlEscapedString.replace(/(^|[\\r\\n\\t ]) /g, '$1&#160;');\n  }\n  if (options.preserveNewlines) {\n    htmlEscapedString = htmlEscapedString.replace(/(\\r\\n|\\n|\\r)/g, '<br>');\n  }\n  if (options.preserveTabs) {\n    htmlEscapedString = htmlEscapedString.replace(/(\\t+)/g, '<span style=\"white-space:pre\">$1</span>');\n  }\n  return createHtmlInternal(htmlEscapedString);\n}\n/**\n * Creates a `SafeHtml` representing a script tag with inline script content.\n */\nexport function scriptToHtml(script, options = {}) {\n  const unwrappedScript = unwrapScript(script).toString();\n  let stringTag = `<script`;\n  if (options.id) {\n    stringTag += ` id=\"${htmlEscapeToString(options.id)}\"`;\n  }\n  if (options.nonce) {\n    stringTag += ` nonce=\"${htmlEscapeToString(options.nonce)}\"`;\n  }\n  if (options.type) {\n    stringTag += ` type=\"${htmlEscapeToString(options.type)}\"`;\n  }\n  if (options.defer) {\n    stringTag += ` defer`;\n  }\n  stringTag += `>${unwrappedScript}\\u003C/script>`;\n  return createHtmlInternal(stringTag);\n}\n/**\n * Creates a `SafeHtml` representing a script tag with the src attribute.\n * This also supports CSP nonces and async loading.\n */\nexport function scriptUrlToHtml(src, options = {}) {\n  const unwrappedSrc = unwrapResourceUrl(src).toString();\n  let stringTag = `<script src=\"${htmlEscapeToString(unwrappedSrc)}\"`;\n  if (options.async) {\n    stringTag += ' async';\n  }\n  if (options.customElement) {\n    stringTag += ` custom-element=\"${htmlEscapeToString(options.customElement)}\"`;\n  }\n  if (options.defer) {\n    stringTag += ` defer`;\n  }\n  if (options.id) {\n    stringTag += ` id=\"${htmlEscapeToString(options.id)}\"`;\n  }\n  if (options.nonce) {\n    stringTag += ` nonce=\"${htmlEscapeToString(options.nonce)}\"`;\n  }\n  if (options.type) {\n    stringTag += ` type=\"${htmlEscapeToString(options.type)}\"`;\n  }\n  if (options.crossorigin) {\n    stringTag += ` crossorigin=\"${htmlEscapeToString(options.crossorigin)}\"`;\n  }\n  stringTag += '>\\u003C/script>';\n  return createHtmlInternal(stringTag);\n}\n/**\n * HTML-escapes the given text (`&`, `<`, `>`, `\"` and `'`).\n */\nfunction htmlEscapeToString(text) {\n  const escaped = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, '&quot;').replace(/'/g, '&apos;');\n  return escaped;\n}\n/** Creates a `SafeHtml` value by concatenating multiple `SafeHtml`s. */\nexport function concatHtmls(htmls) {\n  return joinHtmls('', htmls);\n}\n/**\n * Creates a `SafeHtml` value by concatenating multiple `SafeHtml`s interleaved\n * with a separator.\n */\nexport function joinHtmls(separator, htmls) {\n  const separatorHtml = htmlEscape(separator);\n  return createHtmlInternal(htmls.map(value => unwrapHtml(htmlEscape(value))).join(unwrapHtml(separatorHtml).toString()));\n}\n/**\n * Returns a `SafeHtml` that contains `<!DOCTYPE html>`.\n * This is defined as a function to prevent the definition of a Trusted Type\n * policy when simply importing safevalues.\n */\nexport function doctypeHtml() {\n  return createHtmlInternal('<!DOCTYPE html>');\n}\n/**\n * Non-exported version of `nodeToHtml`, with an explicit temporary root to\n * accomodate for the sanitizer's user case.\n */\nexport function nodeToHtmlInternal(node, temporaryRoot) {\n  temporaryRoot.appendChild(node);\n  // XML serialization is preferred over HTML serialization as it is\n  // stricter and makes sure all attributes are properly escaped, avoiding\n  // cases where the tree might mutate when parsed again later due to the\n  // complexities of the HTML parsing algorithm\n  let serializedNewTree = new XMLSerializer().serializeToString(temporaryRoot);\n  // We remove the outer most element as this is the span node created as\n  // the root for the sanitized tree and contains a spurious xmlns attribute\n  // from the XML serialization step.\n  serializedNewTree = serializedNewTree.slice(serializedNewTree.indexOf('>') + 1, serializedNewTree.lastIndexOf('</'));\n  return createHtmlInternal(serializedNewTree);\n}\n/**\n * Serializes a Node into it's HTML representation.\n *\n * Note: this method uses strict XML serialization to mitigate mutation issues\n * when the html is then re-parsed by the browser.\n */\nexport function nodeToHtml(node) {\n  const tempRoot = document.createElement('span');\n  return nodeToHtmlInternal(node, tempRoot);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}