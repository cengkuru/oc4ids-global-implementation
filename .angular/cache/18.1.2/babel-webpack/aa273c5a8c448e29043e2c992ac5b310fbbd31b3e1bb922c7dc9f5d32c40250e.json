{"ast":null,"code":"/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport '../../environment/dev.js';\nimport { pure } from '../../internals/pure.js';\nimport { ensureTokenIsValid, secretToken } from '../../internals/secrets.js';\nimport { nodeToHtmlInternal } from '../html_builders.js';\nimport { restrictivelySanitizeUrl } from '../url_builders.js';\nimport { createInertFragment } from './inert_fragment.js';\nimport { getNodeName, isElement, isText } from './no_clobber.js';\nimport { parseUrl, ResourceUrlPolicyHintsType } from './resource_url_policy.js';\nimport { DEFAULT_SANITIZER_TABLE } from './sanitizer_table/default_sanitizer_table.js';\nimport { AttributePolicyAction } from './sanitizer_table/sanitizer_table.js';\n/** Implementation for `HtmlSanitizer` */\nexport class HtmlSanitizerImpl {\n  constructor(sanitizerTable, token, styleElementSanitizer, styleAttributeSanitizer, resourceUrlPolicy) {\n    this.sanitizerTable = sanitizerTable;\n    this.styleElementSanitizer = styleElementSanitizer;\n    this.styleAttributeSanitizer = styleAttributeSanitizer;\n    this.resourceUrlPolicy = resourceUrlPolicy;\n    this.changes = [];\n    ensureTokenIsValid(token);\n  }\n  sanitizeAssertUnchanged(html) {\n    if (process.env.NODE_ENV !== 'production') {\n      this.changes = [];\n    }\n    const sanitizedHtml = this.sanitize(html);\n    if (process.env.NODE_ENV !== 'production' && this.changes.length !== 0) {\n      throw new Error(`Unexpected change to HTML value as a result of sanitization. ` + `Input: \"${html}\", sanitized output: \"${sanitizedHtml}\"\\n` + `List of changes:${this.changes.join('\\n')}`);\n    }\n    return sanitizedHtml;\n  }\n  sanitize(html) {\n    const inertDocument = document.implementation.createHTMLDocument('');\n    return nodeToHtmlInternal(this.sanitizeToFragmentInternal(html, inertDocument), inertDocument.body);\n  }\n  sanitizeToFragment(html) {\n    const inertDocument = document.implementation.createHTMLDocument('');\n    return this.sanitizeToFragmentInternal(html, inertDocument);\n  }\n  sanitizeToFragmentInternal(html, inertDocument) {\n    const dirtyFragment = createInertFragment(html, inertDocument);\n    const treeWalker = document.createTreeWalker(dirtyFragment, 5 /* NodeFilter.SHOW_ELEMENT | NodeFilter.SHOW_TEXT */, n => this.nodeFilter(n));\n    // `nextNode` is called so we skip the root `DocumentFragment`.\n    let currentNode = treeWalker.nextNode();\n    // We create a root element to attach all the children of the body to. We\n    // use div as it as a semantic-free, generic container and does not\n    // represent anything. This is removed when we serialize the tree back\n    // into a string.\n    const sanitizedFragment = inertDocument.createDocumentFragment();\n    let sanitizedParent = sanitizedFragment;\n    while (currentNode !== null) {\n      let sanitizedNode;\n      if (isText(currentNode)) {\n        if (this.styleElementSanitizer && sanitizedParent.nodeName === 'STYLE') {\n          // TODO(securitymb): The sanitizer should record a change whenever\n          // any meaningful change is made to the stylesheet.\n          const sanitizedCss = this.styleElementSanitizer(currentNode.data);\n          sanitizedNode = this.createTextNode(sanitizedCss);\n        } else {\n          sanitizedNode = this.sanitizeTextNode(currentNode);\n        }\n      } else if (isElement(currentNode)) {\n        sanitizedNode = this.sanitizeElementNode(currentNode, inertDocument);\n      } else {\n        let message = '';\n        if (process.env.NODE_ENV !== 'production') {\n          message = 'Node is not of type text or element';\n        }\n        throw new Error(message);\n      }\n      sanitizedParent.appendChild(sanitizedNode);\n      // Advance iterator while keeping track of the sanitized parent for the\n      // current node\n      currentNode = treeWalker.firstChild();\n      if (currentNode) {\n        sanitizedParent = sanitizedNode;\n      } else {\n        while (!(currentNode = treeWalker.nextSibling())) {\n          if (!(currentNode = treeWalker.parentNode())) {\n            break;\n          }\n          sanitizedParent = sanitizedParent.parentNode;\n        }\n      }\n    }\n    return sanitizedFragment;\n  }\n  createTextNode(text) {\n    return document.createTextNode(text);\n  }\n  sanitizeTextNode(textNode) {\n    return this.createTextNode(textNode.data);\n  }\n  sanitizeElementNode(elementNode, inertDocument) {\n    const elementName = getNodeName(elementNode);\n    const newNode = inertDocument.createElement(elementName);\n    const dirtyAttributes = elementNode.attributes;\n    for (const {\n      name,\n      value\n    } of dirtyAttributes) {\n      const policy = this.sanitizerTable.getAttributePolicy(name, elementName);\n      if (!this.satisfiesAllConditions(policy.conditions, dirtyAttributes)) {\n        this.recordChange(`Not all conditions satisfied for attribute: ${name}.`);\n        continue;\n      }\n      switch (policy.policyAction) {\n        case AttributePolicyAction.KEEP:\n          setAttribute(newNode, name, value);\n          break;\n        case AttributePolicyAction.KEEP_AND_SANITIZE_URL:\n          const sanitizedAttrUrl = restrictivelySanitizeUrl(value);\n          if (sanitizedAttrUrl !== value) {\n            this.recordChange(`Url in attribute ${name} was modified during sanitization. Original url:\"${value}\" was sanitized to: \"${sanitizedAttrUrl}\"`);\n          }\n          setAttribute(newNode, name, sanitizedAttrUrl);\n          break;\n        case AttributePolicyAction.KEEP_AND_NORMALIZE:\n          // We don't consider changing the case of an attribute value to be a\n          // semantic change\n          setAttribute(newNode, name, value.toLowerCase());\n          break;\n        case AttributePolicyAction.KEEP_AND_SANITIZE_STYLE:\n          if (this.styleAttributeSanitizer) {\n            const sanitizedCss = this.styleAttributeSanitizer(value);\n            // TODO(securitymb): The sanitizer should record a change whenever\n            // any meaningful change is made to the stylesheet.\n            setAttribute(newNode, name, sanitizedCss);\n          } else {\n            setAttribute(newNode, name, value);\n          }\n          break;\n        case AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY:\n          if (this.resourceUrlPolicy) {\n            const hints = {\n              type: ResourceUrlPolicyHintsType.HTML_ATTRIBUTE,\n              attributeName: name,\n              tagName: elementName\n            };\n            const url = parseUrl(value);\n            const sanitizedUrl = this.resourceUrlPolicy(url, hints);\n            // TODO(securitymb): A change should be recorded if the resource url\n            // changes the URL.\n            if (sanitizedUrl) {\n              setAttribute(newNode, name, sanitizedUrl.toString());\n            }\n            // If null is returned, the attribute is dropped.\n          } else {\n            // If the resource url policy is not set, we allow all resources.\n            // This is how the sanitizer behaved before the resource url policy\n            // was introduced.\n            setAttribute(newNode, name, value);\n          }\n          break;\n        case AttributePolicyAction.KEEP_AND_USE_RESOURCE_URL_POLICY_FOR_SRCSET:\n          if (this.resourceUrlPolicy) {\n            const hints = {\n              type: ResourceUrlPolicyHintsType.HTML_ATTRIBUTE,\n              attributeName: name,\n              tagName: elementName\n            };\n            const srcset = parseSrcset(value);\n            const sanitizedSrcset = {\n              parts: []\n            };\n            for (const part of srcset.parts) {\n              const url = parseUrl(part.url);\n              const sanitizedUrl = this.resourceUrlPolicy(url, hints);\n              if (sanitizedUrl) {\n                sanitizedSrcset.parts.push({\n                  url: sanitizedUrl.toString(),\n                  descriptor: part.descriptor\n                });\n              }\n            }\n            setAttribute(newNode, name, serializeSrcset(sanitizedSrcset));\n          } else {\n            // If the resource url policy is not set, we allow all resources.\n            // This is how the sanitizer behaved before the resource url\n            // policy was introduced.\n            setAttribute(newNode, name, value);\n          }\n          break;\n        case AttributePolicyAction.DROP:\n          this.recordChange(`Attribute: ${name} was dropped`);\n          break;\n        default:\n          if (process.env.NODE_ENV !== 'production') {\n            checkExhaustive(policy.policyAction, 'Unhandled AttributePolicyAction case');\n          }\n      }\n    }\n    return newNode;\n  }\n  nodeFilter(node) {\n    if (isText(node)) {\n      return 1; // NodeFilter.FILTER_ACCEPT\n    } else if (!isElement(node)) {\n      // Getting a node that is neither an `Element` or a `Text` node. This is\n      // likely due to something that is not supposed to be an element in user\n      // code but recognized as such by the TreeWalker (e.g. a polyfill for\n      // other kind of nodes). Since we can't recognize it as an element, we\n      // drop the node, but we don't record it as a meaningful change.\n      return 2; // NodeFilter.FILTER_REJECT\n    }\n    const nodeName = getNodeName(node);\n    if (nodeName === null) {\n      this.recordChange(`Node name was null for node: ${node}`);\n      return 2; // NodeFilter.FILTER_REJECT\n    }\n    if (this.sanitizerTable.isAllowedElement(nodeName)) {\n      return 1; // NodeFilter.FILTER_ACCEPT\n    }\n    this.recordChange(`Element: ${nodeName} was dropped`);\n    return 2; // NodeFilter.FILTER_REJECT\n  }\n  recordChange(errorMessage) {\n    if (process.env.NODE_ENV !== 'production') {\n      this.changes.push(errorMessage);\n    }\n  }\n  satisfiesAllConditions(conditions, attrs) {\n    var _a;\n    if (!conditions) {\n      return true;\n    }\n    for (const [attrName, expectedValues] of conditions) {\n      const value = (_a = attrs.getNamedItem(attrName)) === null || _a === void 0 ? void 0 : _a.value;\n      if (value && !expectedValues.has(value)) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\n/** @noinline Helper to save on codesize. */\nfunction setAttribute(el, name, value) {\n  el.setAttribute(name, value);\n}\n/**\n * Parses a srcset attribute into a structured representation.\n *\n * @param srcset The srcset attribute value.\n * @return The parsed srcset.\n */\nexport function parseSrcset(srcset) {\n  // The algorithm is described in the spec at\n  // https://html.spec.whatwg.org/multipage/images.html#srcset-attributes.\n  //\n  // The code below is greatly simplified though; we don't check the validity of\n  // the descriptors, only extract them. If they happen to be invalid, the\n  // browser will ignore them anyway.\n  const parts = [];\n  for (const part of srcset.split(',')) {\n    const [url, descriptor] = part.trim().split(/\\s+/, 2);\n    parts.push({\n      url,\n      descriptor\n    });\n  }\n  return {\n    parts\n  };\n}\n/**\n * Serializes a srcset into a string.\n *\n * @param srcset The srcset to serialize.\n * @return The serialized srcset.\n */\nexport function serializeSrcset(srcset) {\n  return srcset.parts.map(part => {\n    const {\n      url,\n      descriptor\n    } = part;\n    return `${url}${descriptor ? ` ${descriptor}` : ''}`;\n  })\n  // We always add whitespaces around the parts to remove the ambiguity of\n  // whether a comma character is a part of the URL or not.\n  .join(' , ');\n}\nconst defaultHtmlSanitizer = /* #__PURE__ */pure(() => new HtmlSanitizerImpl(DEFAULT_SANITIZER_TABLE, secretToken));\n/** Sanitizes untrusted html using the default sanitizer configuration. */\nexport function sanitizeHtml(html) {\n  return defaultHtmlSanitizer.sanitize(html);\n}\n/**\n * Sanitizes untrusted html using the default sanitizer configuration. Throws\n * an error if the html was changed.\n */\nexport function sanitizeHtmlAssertUnchanged(html) {\n  return defaultHtmlSanitizer.sanitizeAssertUnchanged(html);\n}\n/**\n * Sanitizes untrusted html using the default sanitizer configuration. Throws\n * an error if the html was changed.\n */\nexport function sanitizeHtmlToFragment(html) {\n  return defaultHtmlSanitizer.sanitizeToFragment(html);\n}\nfunction checkExhaustive(value, msg = `unexpected value ${value}!`) {\n  throw new Error(msg);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}