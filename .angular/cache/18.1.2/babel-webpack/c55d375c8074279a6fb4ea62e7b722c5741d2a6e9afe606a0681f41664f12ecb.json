{"ast":null,"code":"/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport '../environment/dev.js';\nimport { createResourceUrlInternal, unwrapResourceUrl } from '../internals/resource_url_impl.js';\nimport { unwrapScript } from '../internals/script_impl.js';\nimport { assertIsTemplateObject } from '../internals/string_literal.js';\n/**\n * Check whether the base url contains a valid origin,\n *\n * A string for an origin must contain only alphanumeric or any of the\n * following: `-.:`, and must not be an IP address. Remember that, as per the\n * documentation for TrustedResourceUrl, the origin must be trustworthy.\n *\n * @param base The base url that contains an origin.\n */\nfunction hasValidOrigin(base) {\n  if (!(/^https:\\/\\//.test(base) || /^\\/\\//.test(base))) {\n    return false;\n  }\n  const originStart = base.indexOf('//') + 2;\n  const originEnd = base.indexOf('/', originStart);\n  // If the base url only contains the prefix (e.g. //), or the slash\n  // for the origin is right after the prefix (e.g. ///), the origin is\n  // missing.\n  if (originEnd <= originStart) {\n    throw new Error(`Can't interpolate data in a url's origin, ` + `Please make sure to fully specify the origin, terminated with '/'.`);\n  }\n  const origin = base.substring(originStart, originEnd);\n  if (!/^[0-9a-z.:-]+$/i.test(origin)) {\n    throw new Error('The origin contains unsupported characters.');\n  }\n  if (!/^[^:]*(:[0-9]+)?$/i.test(origin)) {\n    throw new Error('Invalid port number.');\n  }\n  if (!/(^|\\.)[a-z][^.]*$/i.test(origin)) {\n    throw new Error('The top-level domain must start with a letter.');\n  }\n  return true;\n}\n/**\n * Check whether the base url contains a valid about url at its beginning.\n *\n * An about url is either exactly 'about:blank' or 'about:blank#<str>' where\n * <str> can be an arbitrary string.\n *\n * @param base The base url.\n */\nfunction isValidAboutUrl(base) {\n  if (!/^about:blank/.test(base)) {\n    return false;\n  }\n  if (base !== 'about:blank' && !/^about:blank#/.test(base)) {\n    throw new Error('The about url is invalid.');\n  }\n  return true;\n}\n/**\n * Check whether the base url contains a valid path start at its beginning.\n *\n * A valid path start is either a '/' or a '/' followed by at least one\n * character that is not '/' or '\\'.\n *\n * @param base The base url.\n */\nfunction isValidPathStart(base) {\n  if (!/^\\//.test(base)) {\n    return false;\n  }\n  if (base === '/' || base.length > 1 && base[1] !== '/' && base[1] !== '\\\\') {\n    return true;\n  }\n  throw new Error('The path start in the url is invalid.');\n}\n/**\n * Check whether the base url contains a valid relative path start at its\n * beginning.\n *\n * A valid relative path start is a non empty string that has no ':', '/' nor\n * '\\', and that is followed by a '/'.\n *\n * @param base The base url.\n */\nfunction isValidRelativePathStart(base) {\n  // Using the RegExp syntax as the native JS RegExp syntax is not well handled\n  // by some downstream bundlers with this regex.\n  return new RegExp('^[^:\\\\s\\\\\\\\/]+/').test(base);\n}\n/**\n * Splits an url into segments using '?' and '#' delimiters.\n *\n * The URL can later be put back together by concatenating the returned segments\n * like: path + params + hash. Note that the delimiters '?' and '#' will\n * already be included in 'params' and 'hash' values respectively when these are\n * not empty.\n *\n * @param url The url to split.\n */\nfunction getUrlSegments(url) {\n  const segments = url.split(/\\?|#/);\n  const params = /\\?/.test(url) ? '?' + segments[1] : '';\n  const hash = /#/.test(url) ? '#' + (params ? segments[2] : segments[1]) : '';\n  return {\n    path: segments[0],\n    params,\n    hash\n  };\n}\n/**\n * Builds TrustedResourceUrl from a template literal.\n *\n * This factory is a template literal tag function. It should be called with\n * a template literal, with or without embedded expressions. For example,\n *               trustedResourceUrl`//example.com/${bar}`;\n * or\n *               trustedResourceUrl`//example.com`;\n *\n * When this function is called with a template literal without any embedded\n * expressions, the template string may contain anything as the whole URL is\n * a compile-time string constant.\n *\n * When this function is called with a template literal that contains embedded\n * expressions, the template must start with one of the following:\n * - `https://<origin>/`\n * - `//<origin>/`\n * - `/<pathStart>`\n * - `<relativePathStart>/`\n * - `about:blank`\n * - `data:`\n *\n * `<origin>` must contain only alphanumeric or any of the following: `-.:`.\n * Remember that, as per the documentation for TrustedResourceUrl, the origin\n * must be trustworthy. An origin of \"example.com\" could be set with this\n * method, but would tie the security of your site to the security of\n * example.com. Similarly, formats that potentially cover redirects hosted\n * on a trusted origin are problematic, since that could lead to untrusted\n * origins.\n *\n * `<pathStart>` is either an empty string, or a non empty string that does not\n * start with '/' or '\\'.\n * In other words, `/<pathStart>` is either a '/' or a\n * '/' followed by at least one character that is not '/' or '\\'.\n *\n * `<relativePathStart> is a non empty string that has no ':', '/' nor '\\'.\n *\n * `data:` (data URL) does not allow embedded expressions in the template\n * literal input.\n *\n * All embedded expressions are URL encoded when they are interpolated. Do not\n * embed expressions that are already URL encoded as they will be double encoded\n * by the builder.\n *\n * @param templateObj This contains the literal part of the template literal.\n * @param rest This represents the template's embedded expressions.\n */\nexport function trustedResourceUrl(templateObj, ...rest) {\n  // Check if templateObj is actually from a template literal.\n  if (process.env.NODE_ENV !== 'production') {\n    assertIsTemplateObject(templateObj, rest.length);\n  }\n  if (rest.length === 0) {\n    return createResourceUrlInternal(templateObj[0]);\n  }\n  const base = templateObj[0].toLowerCase();\n  if (process.env.NODE_ENV !== 'production') {\n    if (/^data:/.test(base)) {\n      throw new Error('Data URLs cannot have expressions in the template literal input.');\n    }\n    if (!hasValidOrigin(base) && !isValidPathStart(base) && !isValidRelativePathStart(base) && !isValidAboutUrl(base)) {\n      throw new Error('Trying to interpolate expressions in an unsupported url format.');\n    }\n  }\n  let url = templateObj[0];\n  for (let i = 0; i < rest.length; i++) {\n    url += encodeURIComponent(rest[i]) + templateObj[i + 1];\n  }\n  return createResourceUrlInternal(url);\n}\n/**\n * Creates a new TrustedResourceUrl with params added to the URL's search\n * parameters.\n *\n * @param params What to add to the URL. Parameters with value `null` or\n * `undefined` are skipped. Both keys and values will be encoded. Do not pass\n * pre-encoded values as this will result them being double encoded. If the\n * value is an array then the same parameter is added for every element in the\n * array.\n */\nexport function appendParams(trustedUrl, params) {\n  const urlSegments = getUrlSegments(unwrapResourceUrl(trustedUrl).toString());\n  let urlParams = urlSegments.params;\n  let separator = urlParams.length ? '&' : '?';\n  // for-of has a big polyfill.\n  // tslint:disable-next-line:ban-iterable-foreach\n  params.forEach((value, key) => {\n    const values = value instanceof Array ? value : [value];\n    for (let i = 0; i < values.length; i++) {\n      const v = values[i];\n      if (v === null || v === undefined) {\n        continue;\n      }\n      urlParams += separator + encodeURIComponent(key) + '=' + encodeURIComponent(String(v));\n      separator = '&';\n    }\n  });\n  return createResourceUrlInternal(urlSegments.path + urlParams + urlSegments.hash);\n}\nconst BEFORE_FRAGMENT_REGEXP = /[^#]*/;\n/**\n * Creates a new TrustedResourceUrl based on an existing one but with the\n * addition of a fragment (the part after `#`). If the URL already has a\n * fragment, it is replaced with the new one.\n * @param fragment The fragment to add to the URL, verbatim, without the leading\n * `#`. No additional escaping is applied.\n */\nexport function replaceFragment(trustedUrl, fragment) {\n  const urlString = unwrapResourceUrl(trustedUrl).toString();\n  return createResourceUrlInternal(BEFORE_FRAGMENT_REGEXP.exec(urlString)[0] + '#' + fragment);\n}\n/**\n * Creates a new TrustedResourceUrl based on an existing one with a single\n * subpath segment added to the end of the existing path and prior to any query\n * parameters and/or fragments that already exist in the URL.\n * @param pathSegment The singular sub path being added to the URL. Do not pass\n *     a pre-encoded value as this will result in it being double encoded.\n */\nexport function appendPathSegment(trustedUrl, pathSegment) {\n  const urlSegments = getUrlSegments(unwrapResourceUrl(trustedUrl).toString());\n  const separator = urlSegments.path.slice(-1) === '/' ? '' : '/';\n  const newPath = urlSegments.path + separator + encodeURIComponent(pathSegment);\n  return createResourceUrlInternal(newPath + urlSegments.params + urlSegments.hash);\n}\n/**\n * Creates a `TrustedResourceUrl` by generating a `Blob` from a\n * `SafeScript` and then calling `URL.createObjectURL` with that `Blob`.\n *\n * Caller must call `URL.revokeObjectURL()` on the stringified url to\n * release the underlying `Blob`.\n */\nexport function objectUrlFromScript(safeScript) {\n  const scriptContent = unwrapScript(safeScript).toString();\n  const blob = new Blob([scriptContent], {\n    type: 'text/javascript'\n  });\n  return createResourceUrlInternal(URL.createObjectURL(blob));\n}\n/**\n * A function to safely retrieve the base URI from the Window object and set it\n * at the beginning of a given path-relative (starts with \"/\") resource url.\n *\n * @param pathRelativeUrl The resource to which the origin shall be prepended.\n */\nexport function toAbsoluteResourceUrl(pathRelativeUrl) {\n  const originalUrl = unwrapResourceUrl(pathRelativeUrl).toString();\n  const qualifiedUrl = new URL(originalUrl, window.document.baseURI);\n  return createResourceUrlInternal(qualifiedUrl.toString());\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}