{"ast":null,"code":"/**\n * @license\n * SPDX-License-Identifier: Apache-2.0\n */\nimport '../environment/dev.js';\n/**\n * Extracts the scheme from the given URL. If the URL is relative, https: is\n * assumed.\n * @param url The URL to extract the scheme from.\n * @return the URL scheme.\n */\nexport function extractScheme(url) {\n  let parsedUrl;\n  try {\n    parsedUrl = new URL(url);\n  } catch (e) {\n    // According to https://url.spec.whatwg.org/#constructors, the URL\n    // constructor with one parameter throws if `url` is not absolute. In this\n    // case, we are sure that no explicit scheme (javascript: ) is set.\n    // This can also be a URL parsing error, but in this case the URL won't be\n    // run anyway.\n    return 'https:';\n  }\n  return parsedUrl.protocol;\n}\n// We can't use an ES6 Set here because gws somehow depends on this code and\n// doesn't want to pay the cost of a polyfill.\nconst ALLOWED_SCHEMES = ['data:', 'http:', 'https:', 'mailto:', 'ftp:'];\n/**\n * A pattern that blocks javascript: URLs. Matches\n * (a) Urls with an explicit scheme that is not javascript and that only has\n *     alphanumeric or [.-+_] characters; or\n * (b) Urls with no explicit scheme. The pattern allows the first colon\n *     (`:`) character to appear after one of  the `/` `?` or `#` characters,\n *     which means the colon appears in path, query or fragment part of the URL.\n */\nexport const IS_NOT_JAVASCRIPT_URL_PATTERN = /^\\s*(?!javascript:)(?:[\\w+.-]+:|[^:/?#]*(?:[/?#]|$))/i;\n/**\n * Checks whether a urls has a `javascript:` scheme.\n * If the url has a `javascript:` scheme, reports it and returns true.\n * Otherwise, returns false.\n */\nexport function reportJavaScriptUrl(url) {\n  const hasJavascriptUrlScheme = !IS_NOT_JAVASCRIPT_URL_PATTERN.test(url);\n  if (hasJavascriptUrlScheme) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error(`A URL with content '${url}' was sanitized away.`);\n    }\n  }\n  return hasJavascriptUrlScheme;\n}\n/**\n * Checks that the URL scheme is not javascript.\n * The URL parsing relies on the URL API in browsers that support it.\n * @param url The URL to sanitize for a SafeUrl sink.\n * @return undefined if url has a javascript: scheme, the original URL\n *     otherwise.\n */\nexport function sanitizeJavaScriptUrl(url) {\n  if (reportJavaScriptUrl(url)) {\n    return undefined;\n  }\n  return url;\n}\n/**\n * Adapter to sanitize string URLs in DOM sink wrappers.\n * @return undefined if the URL was sanitized.\n */\nexport function unwrapUrlOrSanitize(url) {\n  return sanitizeJavaScriptUrl(url);\n}\n/**\n * Sanitizes a URL restrictively.\n * This sanitizer protects against XSS and potentially other uncommon and\n * undesirable schemes that an attacker could use e.g. phishing (tel:, callto:\n * ssh: etc schemes). This sanitizer is primarily meant to be used by the HTML\n * sanitizer.\n */\nexport function restrictivelySanitizeUrl(url) {\n  const parsedScheme = extractScheme(url);\n  if (parsedScheme !== undefined && ALLOWED_SCHEMES.indexOf(parsedScheme.toLowerCase()) !== -1) {\n    return url;\n  }\n  return 'about:invalid#zClosurez';\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}